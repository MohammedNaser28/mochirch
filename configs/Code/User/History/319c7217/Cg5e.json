{
  "Template & Setup": {
    "C++ Competitive Programming Template": {
      "prefix": "mochi",
      "body": [
        "// g++ -o mochi mochi.cpp && ./mochi",
        "// Created by HP on ${CURRENT_YEAR}-${CURRENT_MONTH}-${CURRENT_DATE} ${CURRENT_HOUR}:${CURRENT_MINUTE}:${CURRENT_SECOND}",
        "// ----------------> practice makes perfect <----------------",
        "#include <bits/stdc++.h>",
        "#include <iomanip>",
        "using namespace std;",
        "",
        "#define ll long long",
        "#define mochi ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);",
        "#define infile freopen(\"input.txt\", \"r\", stdin);",
        "#define debug(x) cout << #x << \" = \" << x << endl;",
        "#define debug2(x, y) cout << #x << \" = \" << x << \", \" << #y << \" = \" << y << endl;",
        "",
        "void pewpew() {",
        "\t$0",
        "}",
        "",
        "signed main() {",
        "\tmochi;",
        "\tint x_x = 1;",
        "\t// cin >> x_x;",
        "\twhile (x_x --> 0) {",
        "\t\tpewpew();",
        "\t}",
        "\treturn 0;",
        "}",
        "//-------------------------------------Ende-----------------------------------------//"
      ],
      "description": "Basic CP template with fast I/O"
    },
    
    "Common Includes & Macros": {
      "prefix": "includes",
      "body": [
        "#include <bits/stdc++.h>",
        "using namespace std;",
        "#define ll long long",
        "#define pb push_back",
        "#define mp make_pair",
        "#define fi first",
        "#define se second",
        "#define sz(x) ((int)(x).size())",
        "#define all(x) (x).begin(), (x).end()"
      ],
      "description": "Essential includes and macros"
    }
  },

  "Constants & Config": {
    "Common Constants": {
      "prefix": "constants",
      "body": [
        "const ll INF = 1e18;",
        "const int MAXN = 2e5 + 5;",
        "const ll MOD = 1e9 + 7;",
        "const double EPS = 1e-9;",
        "const double PI = acos(-1.0);"
      ],
      "description": "Frequently used constants"
    },

    "File I/O": {
      "prefix": "fileio",
      "body": [
        "freopen(\"${1:input.txt}\", \"r\", stdin);",
        "freopen(\"${2:output.txt}\", \"w\", stdout);"
      ],
      "description": "File input/output redirection"
    }
  },

  "Math & Bit Operations": {
    "Bit Manipulation": {
      "prefix": "bitops",
      "body": [
        "#define setbit(x, i) (x |= (1LL << i))",
        "#define clearbit(x, i) (x &= ~(1LL << i))",
        "#define togglebit(x, i) (x ^= (1LL << i))",
        "#define checkbit(x, i) ((x & (1LL << i)) != 0)",
        "#define lsb(x) (x & (-x))",
        "#define msb(x) (63 - __builtin_clzll(x))",
        "#define popcount(x) __builtin_popcountll(x)"
      ],
      "description": "Bit manipulation macros"
    },

    "Modular Arithmetic": {
      "prefix": "modmath",
      "body": [
        "ll add(ll a, ll b, ll mod = MOD) { return (a + b) % mod; }",
        "ll sub(ll a, ll b, ll mod = MOD) { return (a - b + mod) % mod; }",
        "ll mul(ll a, ll b, ll mod = MOD) { return (a * b) % mod; }",
        "",
        "ll modpow(ll base, ll exp, ll mod = MOD) {",
        "\tll res = 1;",
        "\twhile (exp) {",
        "\t\tif (exp & 1) res = mul(res, base, mod);",
        "\t\tbase = mul(base, base, mod);",
        "\t\texp >>= 1;",
        "\t}",
        "\treturn res;",
        "}",
        "",
        "ll modinv(ll x, ll mod = MOD) { return modpow(x, mod-2, mod); }"
      ],
      "description": "Modular arithmetic operations"
    }
  },

  "Data Structures": {
    "DSU (Disjoint Set Union)": {
      "prefix": "dsu",
      "body": [
        "struct DSU {",
        "\tvector<int> parent, size;",
        "\tDSU(int n) {",
        "\t\tparent.resize(n);",
        "\t\tsize.assign(n, 1);",
        "\t\tiota(all(parent), 0);",
        "\t}",
        "\tint find(int x) {",
        "\t\treturn parent[x] == x ? x : parent[x] = find(parent[x]);",
        "\t}",
        "\tbool unite(int x, int y) {",
        "\t\tx = find(x), y = find(y);",
        "\t\tif (x == y) return false;",
        "\t\tif (size[x] < size[y]) swap(x, y);",
        "\t\tparent[y] = x;",
        "\t\tsize[x] += size[y];",
        "\t\treturn true;",
        "\t}",
        "};"
      ],
      "description": "Union-Find data structure"
    },

    "Segment Tree": {
      "prefix": "segtree",
      "body": [
        "struct SegTree {",
        "\tint n;",
        "\tvector<ll> tree;",
        "\tSegTree(vector<ll>& arr) : n(arr.size()) {",
        "\t\ttree.resize(4*n);",
        "\t\tbuild(arr, 1, 0, n-1);",
        "\t}",
        "\tvoid build(vector<ll>& arr, int v, int l, int r) {",
        "\t\tif (l == r) tree[v] = arr[l];",
        "\t\telse {",
        "\t\t\tint m = (l+r)/2;",
        "\t\t\tbuild(arr, 2*v, l, m);",
        "\t\t\tbuild(arr, 2*v+1, m+1, r);",
        "\t\t\ttree[v] = tree[2*v] + tree[2*v+1];",
        "\t\t}",
        "\t}",
        "\tll query(int v, int l, int r, int ql, int qr) {",
        "\t\tif (qr < l || r < ql) return 0;",
        "\t\tif (ql <= l && r <= qr) return tree[v];",
        "\t\tint m = (l+r)/2;",
        "\t\treturn query(2*v, l, m, ql, qr) + query(2*v+1, m+1, r, ql, qr);",
        "\t}",
        "\tvoid update(int v, int l, int r, int pos, ll val) {",
        "\t\tif (l == r) tree[v] = val;",
        "\t\telse {",
        "\t\t\tint m = (l+r)/2;",
        "\t\t\tif (pos <= m) update(2*v, l, m, pos, val);",
        "\t\t\telse update(2*v+1, m+1, r, pos, val);",
        "\t\t\ttree[v] = tree[2*v] + tree[2*v+1];",
        "\t\t}",
        "\t}",
        "};"
      ],
      "description": "Segment tree for range queries"
    }
  },

  "Graph Algorithms": {
    "Dijkstra's Algorithm": {
      "prefix": "dijkstra",
      "body": [
        "vector<ll> dijkstra(int src, vector<vector<pair<int, ll>>>& adj) {",
        "\tvector<ll> dist(adj.size(), INF);",
        "\tpriority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<>> pq;",
        "\tdist[src] = 0;",
        "\tpq.push({0, src});",
        "\twhile (!pq.empty()) {",
        "\t\tauto [d, u] = pq.top(); pq.pop();",
        "\t\tif (d > dist[u]) continue;",
        "\t\tfor (auto [v, w] : adj[u]) {",
        "\t\t\tif (dist[v] > dist[u] + w) {",
        "\t\t\t\tdist[v] = dist[u] + w;",
        "\t\t\t\tpq.push({dist[v], v});",
        "\t\t\t}",
        "\t\t}",
        "\t}",
        "\treturn dist;",
        "}"
      ],
      "description": "Single-source shortest paths"
    },

    "Topological Sort": {
      "prefix": "toposort",
      "body": [
        "vector<int> topoSort(int n, vector<vector<int>>& adj) {",
        "\tvector<int> in(n, 0), order;",
        "\tfor (int u = 0; u < n; u++)",
        "\t\tfor (int v : adj[u]) in[v]++;",
        "\tqueue<int> q;",
        "\tfor (int i = 0; i < n; i++)",
        "\t\tif (in[i] == 0) q.push(i);",
        "\twhile (!q.empty()) {",
        "\t\tint u = q.front(); q.pop();",
        "\t\torder.push_back(u);",
        "\t\tfor (int v : adj[u])",
        "\t\t\tif (--in[v] == 0) q.push(v);",
        "\t}",
        "\treturn order;",
        "}"
      ],
      "description": "Kahn's algorithm for DAGs"
    }
  },

  "Combinatorics": {
    "nCr with Precomputation": {
      "prefix": "ncr",
      "body": [
        "vector<ll> fact, inv;",
        "void precompute(int n) {",
        "\tfact.resize(n+1);",
        "\tinv.resize(n+1);",
        "\tfact[0] = inv[0] = 1;",
        "\tfor (int i = 1; i <= n; i++) {",
        "\t\tfact[i] = mul(fact[i-1], i);",
        "\t\tinv[i] = modinv(fact[i]);",
        "\t}",
        "}",
        "ll nCr(int n, int r) {",
        "\tif (r < 0 || r > n) return 0;",
        "\treturn mul(fact[n], mul(inv[r], inv[n-r]));",
        "}"
      ],
      "description": "Precomputed combinatorics"
    }
  }
}